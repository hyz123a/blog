<!DOCTYPE html>
<html lang="zh-Hans">

<head>
  

  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta http-equiv="cleartype" content="on">
<link rel="alternate" type="application/rss+xml" title="Hyz blog" href="/blog/feed.xml" />
<link href="/blog/static/theme/style.css" rel="stylesheet">


  
<title>C++ 的类 - Hyz blog</title>
<link rel="stylesheet" href="/blog/static/theme/railscasts.min.css">
<script src="/blog/static/theme/highlight.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js"></script>

</head>

<body>
  

  <header class="header">
    <nav class="nav">
      <ul>
        <li><a href="/blog/">首页</a></li>
<li><a href="/blog/about/">关于</a></li>
<li><a href="https://github.com/hyz123a/" target="_blank">GitHub</a></li>
      </ul>
    </nav>
  </header>
  <div class="body">
    
<main class="main page">
  <article class="article">
    <div class="title">
      <h1 class="title">C++ 的类</h1>
    </div>
    
<div class="meta">
  
  <time class="created" datetime="2024-05-29">May 29, 2024</time>
  
</div>

    <div class="content">
      
      <details open>
        <summary>目录：</summary>
        <nav><ul>
<li><a href="#C-类内存布局">C++ 类内存布局</a></li>
<li><a href="#C-类的成员变量初始化顺序">C++ 类的成员变量初始化顺序</a></li>
<li><a href="#当父类存在父类-C-派生类的构造和析构顺序">当父类存在父类, C++ 派生类的构造和析构顺序</a></li>
<li><a href="#使用父类的构造函数构造自己">使用父类的构造函数构造自己</a></li>
<li><a href="#C-类和结构体的区别">C++ 类和结构体的区别</a></li>
</ul></nav>
      </details>
      <hr>
      

      <p>最近经常能够看到 C++ 面经中出现 C++ 类的内存布局及初始化一个派生类时，基类，派生类的构造顺序等这样的问题。同时自己也在这方面存在疑惑，所以就专门去学习了相关的知识，并在查找资历的过程中记录一下。</p>
<p>在开始之前，先看一段代码的输出：</p>
<pre class="highlight"><code class="language-C++">#include &lt;iostream&gt;

class A {
public:
  A(int x) {
    std::cout &lt;&lt; &quot;A's constructor with value: &quot; &lt;&lt; x &lt;&lt; std::endl;
  }
  ~A() {
    std::cout &lt;&lt; &quot;A's deconstructor&quot; &lt;&lt; std::endl;
  }
  virtual void foo() {
    std::cout &lt;&lt; &quot;A::foo&quot; &lt;&lt; std::endl;
  }

private:
  int x_{0};
};

class B : virtual public A {
public:
  B(int x, int y)
      : A(x) {  // 调用父类 A 的构造函数，由于显示的定义了参数构造函数，不会生成默认构造函数
    std::cout &lt;&lt; &quot;B's constructor with value: &quot; &lt;&lt; y &lt;&lt; std::endl;
  }
  ~B() {
    std::cout &lt;&lt; &quot;B's deconstructor&quot; &lt;&lt; std::endl;
  }
  void foo() override {
    std::cout &lt;&lt; &quot;B::foo&quot; &lt;&lt; std::endl;
  }

  int x_{1};
};

class C : virtual public A {
public:
  C(int x, int y)
      : A(x) {  // 调用父类 A 的构造函数
    std::cout &lt;&lt; &quot;C's constructor with value: &quot; &lt;&lt; y &lt;&lt; std::endl;
  }
  ~C() {
    std::cout &lt;&lt; &quot;C's deconstructor&quot; &lt;&lt; std::endl;
  }
  void foo() override {
    std::cout &lt;&lt; &quot;C::foo&quot; &lt;&lt; std::endl;
  }
  void bar() {
    std::cout &lt;&lt; &quot;C::bar&quot; &lt;&lt; std::endl;
  }
  int x_{2};
};

class D : public B, public C {
public:
  D(int x, int y, int z)
      :A(x), B(x, y), C(y, x) {  // 调用父类 B 的构造函数，这里必须调用A的参数构造函数
    std::cout &lt;&lt; &quot;D's constructor with value: &quot; &lt;&lt; z &lt;&lt; std::endl;
  }
  ~D() {
    std::cout &lt;&lt; &quot;D's deconstructor&quot; &lt;&lt; std::endl;
  }
  void foo() override {
    std::cout &lt;&lt; &quot;D::foo&quot; &lt;&lt; std::endl;
  }
  void bar() {
    std::cout &lt;&lt; &quot;D::bar&quot; &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;D::x = &quot; &lt;&lt; &quot; &quot; &lt;&lt; x_ &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;C::x = &quot; &lt;&lt; &quot; &quot; &lt;&lt; C::x_ &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;B::x = &quot; &lt;&lt; &quot; &quot; &lt;&lt; B::x_ &lt;&lt; std::endl;
    C::bar();
  }
  int x_{3};
};

int main() {
  D d(1, 2, 3);
  std::cout &lt;&lt; &quot;\n&quot;;

  d.bar();
  std::cout &lt;&lt; &quot;\n&quot;;

  C* c = &amp;d;
  c-&gt;bar();
  c-&gt;foo();
  std::cout &lt;&lt; &quot;\n&quot;;

  return 0;
}</code></pre>


<p>output:</p>
<pre class="highlight"><code class="language-shell">A's constructor with value: 1
B's constructor with value: 2
C's constructor with value: 1
D's constructor with value: 3

D::bar
D::x =  3
C::x =  2
B::x =  1
C::bar

C::bar
D::foo

D's deconstructor
C's deconstructor
B's deconstructor
A's deconstructor</code></pre>


<h2><a id="C-类内存布局" href="#C-类内存布局" class="anchor"></a>C++ 类内存布局</h2>
<p>执行</p>
<pre class="highlight"><code class="language-bash">clang++ -Xclang -fdump-record-layouts xxx.cpp</code></pre>


<p>输出内存布局为：</p>
<pre class="highlight"><code>*** Dumping AST Record Layout
         0 | class A
         0 |   (A vtable pointer)
         8 |   int x_
           | [sizeof=16, dsize=12, align=8,
           |  nvsize=12, nvalign=8]

*** Dumping AST Record Layout
         0 | class B
         0 |   (B vtable pointer)
         8 |   int x_
        16 |   class A (virtual base)
        16 |     (A vtable pointer)
        24 |     int x_
           | [sizeof=32, dsize=28, align=8,
           |  nvsize=12, nvalign=8]

*** Dumping AST Record Layout
         0 | class C
         0 |   (C vtable pointer)
         8 |   int x_
        16 |   class A (virtual base)
        16 |     (A vtable pointer)
        24 |     int x_
           | [sizeof=32, dsize=28, align=8,
           |  nvsize=12, nvalign=8]

*** Dumping AST Record Layout
         0 | class D
         0 |   class B (primary base)
         0 |     (B vtable pointer)
         8 |     int x_
        16 |   class C (base)
        16 |     (C vtable pointer)
        24 |     int x_
        28 |   int x_
        32 |   class A (virtual base)
        32 |     (A vtable pointer)
        40 |     int x_
           | [sizeof=48, dsize=44, align=8,
           |  nvsize=32, nvalign=8]</code></pre>


<p>执行</p>
<pre class="highlight"><code class="language-shell">clang++ -Xclang -fdump-vtable-layouts xxx.cpp</code></pre>


<p>查看虚函数表实体</p>
<p>虚继承的作用:</p>
<ul>
<li><strong>消除二义性</strong>：在多重继承中，避免了对同一基类的多重实例。</li>
<li><strong>共享基类数据</strong>：派生类可以共享基类的成员，节省内存。</li>
<li><strong>统一接口</strong>：确保派生类通过虚基类访问基类的接口一致。</li>
</ul>
<h2><a id="C-类的成员变量初始化顺序" href="#C-类的成员变量初始化顺序" class="anchor"></a>C++ 类的成员变量初始化顺序</h2>
<ul>
<li>先执行列表初始化，列表初始化未提供的则执行默认初始化</li>
<li>再执行相应的构造函数初始化逻辑</li>
</ul>
<pre class="highlight"><code class="language-C++">class Complex {
public:
    Complex() {}
    Complex(float re) : re_(re) {}
    Complex(float re, float im) : re_(re) , im_(im) {}
private:
    float re_{0};
    float im_{0};
};</code></pre>


<h2><a id="当父类存在父类-C-派生类的构造和析构顺序" href="#当父类存在父类-C-派生类的构造和析构顺序" class="anchor"></a>当父类存在父类, C++ 派生类的构造和析构顺序</h2>
<p>先构造的后析构</p>
<h2><a id="使用父类的构造函数构造自己" href="#使用父类的构造函数构造自己" class="anchor"></a>使用父类的构造函数构造自己</h2>
<p>以下是一个示例：</p>
<pre class="highlight"><code class="language-cpp">#include &lt;iostream&gt;

class Base {
public:
    Base(int x) {
        std::cout &lt;&lt; &quot;Base constructor called with x = &quot; &lt;&lt; x &lt;&lt; std::endl;
    }
};

class Derived : public Base {
public:
    using Base::Base; // Inherit constructors from Base
};

int main() {
    Derived d(42); // Calls Base(int x) constructor
    return 0;
}</code></pre>


<p>在这个例子中，<code>Derived</code>类继承了<code>Base</code>类的构造函数，因此可以直接使用<code>Base</code>类的构造函数来初始化<code>Derived</code>类的对象。运行这个程序将输出：</p>
<pre class="highlight"><code>Base constructor called with x = 42</code></pre>


<p>在C++中，<code>using base::base;</code>这种语法用于继承构造函数。这意味着派生类将继承基类的构造函数，从而可以直接使用基类的构造函数来初始化派生类的对象。</p>
<h2><a id="C-类和结构体的区别" href="#C-类和结构体的区别" class="anchor"></a>C++ 类和结构体的区别</h2>
<p>除了 struct 缺省的成员属性是 public，而 class 是 private 外没有区别。</p>
    </div>
  </article>
  
</main>

  </div>

  
  <footer class="footer" id="footer">
    <p>&copy; 2024-2024 hyz. All rights reserved.</p>
<p>Powered by <a href="https://github.com/verilab/purepress">PurePress</a> and <a
    href="https://github.com/verilab/purepress-theme-minimal">Minimal</a>.</p>
  </footer>

  

  <script>
  let elems = document.getElementsByTagName("a");
  for (let i = 0; i < elems.length; i++) {
    if (elems[i].href.indexOf(document.domain) < 0) {
      elems[i].target = "_blank";
    }
  }
</script>
  
<script>
  // enable code syntax highlight
  hljs.configure({ languages: [] }); // disable language auto detection
  hljs.initHighlightingOnLoad();

  // enable medium-zoom for all images
  mediumZoom(document.querySelectorAll('.content img'));
</script>

</body>

</html>